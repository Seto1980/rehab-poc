<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rehab-Vis 3D Pro (Fixed Logic)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: "Helvetica Neue", Arial, sans-serif; }
        
        /* 映像表示キャンバス */
        canvas#output_canvas { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            object-fit: cover; transform: scaleX(-1); z-index: 1;
        }

        /* グラフエリア（下部） */
        .graph-wrapper {
            position: fixed; bottom: 0; left: 0; right: 0; height: 25vh;
            background: rgba(0, 0, 0, 0.85); border-top: 1px solid #444;
            padding: 10px; box-sizing: border-box; z-index: 10;
        }
        #chart_canvas { width: 100%; height: 100%; }

        /* UIレイヤー */
        .ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5000; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        /* 左右切替ボタン */
        .hand-switch-container {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            z-index: 6000; pointer-events: auto;
            background: rgba(0,0,0,0.6); padding: 5px; border-radius: 30px;
            display: flex; gap: 10px; border: 1px solid #666;
        }
        .hand-btn {
            background: transparent; border: none; color: #ccc;
            padding: 8px 16px; font-weight: bold; cursor: pointer; border-radius: 20px; font-size: 14px;
        }
        .hand-btn.active { background: #00ffcc; color: #000; box-shadow: 0 0 8px #00ffcc; }

        /* スタート画面 */
        #start-screen {
            pointer-events: auto; text-align: center;
            background: rgba(0, 0, 0, 0.85); padding: 30px; border-radius: 20px;
            border: 1px solid #555; backdrop-filter: blur(5px);
            width: 85%; max-width: 350px;
        }
        .app-title { color: #fff; font-size: 20px; margin-bottom: 20px; font-weight: bold; letter-spacing: 1px; }
        #start-btn {
            background: linear-gradient(135deg, #00ffcc, #00ccaa); color: #000;
            border: none; padding: 15px 0; width: 100%; font-size: 20px; font-weight: bold;
            border-radius: 50px; cursor: pointer; margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.4);
        }
        #help-btn {
            background: #444; color: #fff; border: 1px solid #777;
            padding: 10px 0; width: 100%; border-radius: 50px; cursor: pointer; font-size: 14px;
        }

        /* 説明書モーダル */
        #manual-modal {
            display: none; pointer-events: auto; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 9999; overflow-y: auto; -webkit-overflow-scrolling: touch;
        }
        .manual-content {
            background: #1a1a1a; margin: 20px auto; padding: 25px; width: 85%; max-width: 600px;
            border-radius: 15px; border: 1px solid #444; color: #eee; padding-bottom: 50px;
        }
        .close-manual {
            background: #00ffcc; color: #000; border: none; padding: 12px 40px;
            font-weight: bold; border-radius: 30px; cursor: pointer; display: block; margin: 30px auto; font-size: 16px;
        }

        /* カウントダウン & 計測中表示 */
        #countdown-ui, #recording-ui { display: none; pointer-events: none; text-align: center; }
        .countdown-num { font-size: 100px; color: #00ffcc; font-weight: bold; text-shadow: 0 0 20px black; }
        .timer { font-size: 80px; color: #fff; font-weight: bold; }
        .rec-label { color: #ff3366; font-weight: bold; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* 結果画面 */
        #result-ui {
            display: none; pointer-events: auto; background: rgba(15, 15, 15, 0.98);
            padding: 20px; border-radius: 15px; border: 2px solid #00ffcc;
            width: 90%; max-width: 400px; color: #fff;
        }
        .res-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
        .res-item { background: #222; padding: 10px; border-radius: 10px; text-align: center; }
        .res-label { font-size: 11px; color: #aaa; margin-bottom: 5px; text-transform: uppercase; }
        .res-val { font-size: 22px; font-weight: bold; color: #fff; }
        .res-unit { font-size: 11px; color: #888; }
        
        .main-score-box { text-align: center; padding-bottom: 15px; border-bottom: 1px solid #444; }
        .main-score-val { font-size: 50px; font-weight: bold; color: #00ffcc; }
        
        .retry-btn { background: #444; color: #fff; width: 100%; padding: 12px; border-radius: 30px; border: none; cursor: pointer; font-size: 16px; }

    </style>
</head>
<body>
    <video id="input_video" style="display:none" autoplay playsinline></video>

    <div class="hand-switch-container">
        <button class="hand-btn" id="btn-left" onclick="setHand('left')">左腕 (Left)</button>
        <button class="hand-btn active" id="btn-right" onclick="setHand('right')">右腕 (Right)</button>
    </div>

    <div id="manual-modal">
        <div class="manual-content">
            <h3>使い方</h3>
            <p>カメラに向かって手を伸ばしてください。</p>
            <p>「肩」から「手」までの距離を測定し、伸び縮みをグラフ化します。</p>
            <button class="close-manual" onclick="toggleManual(false)">閉じる</button>
        </div>
    </div>

    <div class="ui-layer">
        <div id="start-screen">
            <div class="app-title">Upper Limb Analytics<br><span style="font-size:12px; color:#aaa">Supervised by OT</span></div>
            <button id="start-btn" onclick="startSequence()">計測スタート</button>
            <button id="help-btn" onclick="toggleManual(true)">使い方</button>
        </div>

        <div id="countdown-ui">
            <div class="countdown-num" id="count-val">3</div>
        </div>
        
        <div id="recording-ui">
            <div class="rec-label">● RECORDING</div>
            <div class="timer" id="timer-val">10.0</div>
            <div style="font-size: 20px; color: #00ffcc; margin-top: 10px;">
                Reach: <span id="realtime-reach">0.0</span> m
            </div>
        </div>

        <div id="result-ui">
            <div class="main-score-box">
                <div class="res-label">TOTAL WORK (総運動量)</div>
                <div class="main-score-val" id="res-total">0.0</div>
            </div>
            
            <div class="res-grid">
                <div class="res-item">
                    <div class="res-label">MAX REACH (最大リーチ)</div>
                    <div class="res-val" id="res-max-reach">0.0</div>
                    <div class="res-unit">meters</div>
                </div>
                <div class="res-item">
                    <div class="res-label">DISTANCE (総移動距離)</div>
                    <div class="res-val" id="res-dist">0.0</div>
                    <div class="res-unit">meters</div>
                </div>
                <div class="res-item">
                    <div class="res-label">ACTIVITY (回数)</div>
                    <div class="res-val" id="res-count">0</div>
                    <div class="res-unit">reps</div>
                </div>
                <div class="res-item">
                    <div class="res-label">EVALUATION</div>
                    <div class="res-val" style="font-size:16px" id="res-comment">-</div>
                    <div class="res-unit">feedback</div>
                </div>
            </div>
            
            <button class="retry-btn" onclick="resetApp()">ホームに戻る</button>
        </div>
    </div>

    <canvas id="output_canvas"></canvas>
    <div class="graph-wrapper"><canvas id="chart_canvas"></canvas></div>

    <script>
        // --- 設定 ---
        // 手首: 左=15, 右=16
        // 肩: 左=11, 右=12
        let targetHandIndex = 16; 
        let targetShoulderIndex = 12;

        function toggleManual(show) {
            document.getElementById('manual-modal').style.display = show ? 'block' : 'none';
        }

        function setHand(side) {
            document.getElementById('btn-left').classList.remove('active');
            document.getElementById('btn-right').classList.remove('active');
            document.getElementById(`btn-${side}`).classList.add('active');
            
            if (side === 'left') {
                targetHandIndex = 15;
                targetShoulderIndex = 11;
            } else {
                targetHandIndex = 16;
                targetShoulderIndex = 12;
            }
            resetApp();
        }

        // --- 変数 ---
        let isRecording = false;
        let timerInterval = null;
        let lastTime = 0;
        let lastWrist = null;
        let pathHistory = [];

        // カウント用ステートマシン変数
        let isReaching = false; // 今、手を伸ばしている最中か？
        const REACH_THRESHOLD = 0.40; // 伸びたとみなす距離 (m) ※調整可
        const RETURN_THRESHOLD = 0.25; // 戻ったとみなす距離 (m) ※調整可

        // 計測データ
        let sessionData = {
            totalEnergy: 0,
            maxReach: 0,
            totalDistance: 0,
            moveCount: 0
        };

        // UI Elements
        const startScreen = document.getElementById('start-screen');
        const countdownUI = document.getElementById('countdown-ui');
        const countVal = document.getElementById('count-val');
        const recUI = document.getElementById('recording-ui');
        const resUI = document.getElementById('result-ui');
        const timerDisplay = document.getElementById('timer-val');
        const realtimeReachDisplay = document.getElementById('realtime-reach');
        
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const videoElement = document.getElementById('input_video');

        // Resize
        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Chart.js (グラフ設定) ---
        let energyChart = null;
        try {
            const ctxChart = document.getElementById('chart_canvas').getContext('2d');
            energyChart = new Chart(ctxChart, {
                type: 'line',
                data: {
                    labels: Array(50).fill(''),
                    datasets: [{ 
                        data: Array(50).fill(0), 
                        borderColor: '#00ffcc', 
                        backgroundColor: 'rgba(0, 255, 204, 0.2)', 
                        borderWidth: 2, 
                        tension: 0.1, // 波形を少しシャープに
                        fill: true, 
                        pointRadius: 0 
                    }]
                },
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    animation: false, 
                    scales: { 
                        y: { display: true, min: 0, suggestedMax: 0.8, grid: { color: '#333'} }, // 縦軸はメートル
                        x: { display: false } 
                    }, 
                    plugins: { legend: { display: false } } 
                }
            });
        } catch(e) {}

        // --- シーケンス制御 ---
        function startSequence() {
            startScreen.style.display = 'none';
            countdownUI.style.display = 'block';
            let count = 3;
            countVal.innerText = count;

            const cInterval = setInterval(() => {
                count--;
                if(count > 0) {
                    countVal.innerText = count;
                } else {
                    clearInterval(cInterval);
                    countdownUI.style.display = 'none';
                    startMeasurement();
                }
            }, 1000);
        }

        function startMeasurement() {
            isRecording = true;
            // データリセット
            sessionData = { totalEnergy: 0, maxReach: 0, totalDistance: 0, moveCount: 0 };
            isReaching = false;
            
            let timeLeft = 10.0;
            recUI.style.display = 'block';
            
            pathHistory = [];
            if(energyChart) { 
                energyChart.data.datasets[0].data = Array(50).fill(0); 
                energyChart.update(); 
            }

            timerInterval = setInterval(() => {
                timeLeft -= 0.1;
                if(timeLeft < 0) timeLeft = 0;
                timerDisplay.innerText = timeLeft.toFixed(1);
                
                if(timeLeft <= 0) stopMeasurement();
            }, 100);
        }

        function stopMeasurement() {
            isRecording = false;
            clearInterval(timerInterval);
            recUI.style.display = 'none';
            showResult();
        }

        function showResult() {
            resUI.style.display = 'block';
            
            // 結果表示
            document.getElementById('res-total').innerText = sessionData.totalEnergy.toFixed(1);
            document.getElementById('res-max-reach').innerText = sessionData.maxReach.toFixed(2);
            document.getElementById('res-dist').innerText = sessionData.totalDistance.toFixed(2);
            document.getElementById('res-count').innerText = sessionData.moveCount;

            // フィードバックロジック
            let comment = "Good Try!";
            if(sessionData.maxReach > 0.5) comment = "Excellent Reach!";
            else if(sessionData.moveCount > 8) comment = "High Frequency!";
            else if(sessionData.totalEnergy > 20) comment = "Powerful!";
            else comment = "Keep Practicing!";
            
            document.getElementById('res-comment').innerText = comment;
        }

        function resetApp() {
            resUI.style.display = 'none';
            startScreen.style.display = 'block';
            pathHistory = [];
            if(energyChart) { energyChart.data.datasets[0].data = Array(50).fill(0); energyChart.update(); }
        }

        // --- MediaPipe 処理 ---
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // 必要なランドマークが存在するか確認
            if (results.poseWorldLandmarks && 
                results.poseWorldLandmarks[targetHandIndex] && 
                results.poseWorldLandmarks[targetShoulderIndex]) {
                
                // 1. 座標取得
                const wristWorld = results.poseWorldLandmarks[targetHandIndex]; // 手首(3D)
                const shoulderWorld = results.poseWorldLandmarks[targetShoulderIndex]; // 肩(3D)
                const wristScreen = results.poseLandmarks[targetHandIndex]; // 手首(画面描画用)

                // 2. 「肩」から「手」へのリーチ距離計算 (メートル単位)
                const reachLength = Math.sqrt(
                    Math.pow(wristWorld.x - shoulderWorld.x, 2) +
                    Math.pow(wristWorld.y - shoulderWorld.y, 2) +
                    Math.pow(wristWorld.z - shoulderWorld.z, 2)
                );

                // 3. 速度エネルギー計算 (従来の指標も維持)
                const currentTime = Date.now();
                let currentEnergy = 0;
                
                if (lastWrist && lastTime > 0) {
                    const deltaTime = (currentTime - lastTime) / 1000;
                    if (deltaTime > 0) {
                        const moveDist = Math.sqrt(
                            Math.pow(wristWorld.x - lastWrist.x, 2) +
                            Math.pow(wristWorld.y - lastWrist.y, 2) +
                            Math.pow(wristWorld.z - lastWrist.z, 2)
                        );
                        const velocity = moveDist / deltaTime;
                        
                        // ノイズ除去
                        if(velocity < 15) {
                            currentEnergy = 0.5 * Math.pow(velocity, 2);
                            if(isRecording) {
                                sessionData.totalEnergy += currentEnergy;
                                sessionData.totalDistance += moveDist;
                            }
                        }
                    }
                }

                // 4. ロジック変更点: カウントと最大リーチの更新
                if (isRecording) {
                    // リアルタイム表示更新
                    realtimeReachDisplay.innerText = reachLength.toFixed(2);

                    // 最大リーチ更新
                    if (reachLength > sessionData.maxReach) {
                        sessionData.maxReach = reachLength;
                    }

                    // --- 新しいカウントロジック (ステートマシン) ---
                    // 一定距離伸びたら「リーチ状態」
                    if (!isReaching && reachLength > REACH_THRESHOLD) {
                        isReaching = true; 
                    }
                    // リーチ状態で、一定距離まで戻ったら「1回完了」
                    else if (isReaching && reachLength < RETURN_THRESHOLD) {
                        isReaching = false;
                        sessionData.moveCount++;
                    }
                }

                // 5. グラフ更新 (速度ではなくリーチ距離を表示に変更！)
                if(energyChart) {
                    const data = energyChart.data.datasets[0].data;
                    data.shift(); 
                    data.push(reachLength); // ←ここをEnergyからReachLengthに変更
                    energyChart.update();
                }

                // 6. 描画更新 (軌跡)
                const px = wristScreen.x * canvasElement.width;
                const py = wristScreen.y * canvasElement.height;
                
                // 距離に応じて色を変える (近い=青, 遠い=赤)
                pathHistory.unshift({ x: px, y: py, dist: reachLength });
                if (pathHistory.length > 20) pathHistory.pop();

                if (pathHistory.length > 1) {
                    canvasCtx.lineWidth = 5; canvasCtx.lineCap = 'round';
                    for (let i = 0; i < pathHistory.length - 1; i++) {
                        const pt1 = pathHistory[i]; const pt2 = pathHistory[i+1];
                        canvasCtx.beginPath(); canvasCtx.moveTo(pt1.x, pt1.y); canvasCtx.lineTo(pt2.x, pt2.y);
                        
                        // 色の計算 (0.2m〜0.6mの間で変化)
                        let intensity = (pt1.dist - 0.2) / 0.4;
                        if(intensity < 0) intensity = 0; if(intensity > 1) intensity = 1;
                        
                        const r = Math.floor(255 * intensity);
                        const b = Math.floor(255 * (1 - intensity));
                        canvasCtx.strokeStyle = `rgba(${r}, 100, ${b}, ${1 - i/20})`;
                        canvasCtx.stroke();
                    }
                }
                
                // 現在位置の点
                canvasCtx.beginPath(); canvasCtx.arc(px, py, 10, 0, 2 * Math.PI);
                canvasCtx.fillStyle = isReaching ? "#ff3366" : "#00ffcc"; // リーチ中は赤、戻ったら青
                canvasCtx.fill();

                lastWrist = wristWorld;
                lastTime = currentTime;
            }
            canvasCtx.restore();
        }

        const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
        pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        pose.onResults(onResults);
        
        const camera = new Camera(videoElement, { 
            onFrame: async () => { await pose.send({image: videoElement}); }, 
            width: 640, height: 480 
        });
        camera.start();
    </script>
</body>
</html>